# Алгоритм Определения Аллергенов и Статуса Безопасности (Гибридная Модель)

Этот документ описывает гибридный подход к анализу ингредиентов продукта, сравнению их с аллергенами пользователя и определению статуса безопасности (`safeToConsume`), сочетающий обработку в N8N и финальное решение в мобильном приложении.

## Цели

*   Обеспечить **точное** определение статуса безопасности продукта для пользователя.
*   **Надежно** сравнивать стандартные аллергены, используя **уникальные идентификаторы (ID)**.
*   **Гибко** обрабатывать **кастомные** (добавленные пользователем) аллергены с учетом возможных ошибок ввода и вариаций названий, используя LLM.
*   Поддерживать **многоязычность** как в анализе, так и в отображении результатов.
*   Минимизировать объем данных, передаваемых в основной LLM-запрос N8N.
*   Гарантировать, что сравнение происходит с **актуальным** списком аллергенов пользователя.

## Компоненты и Поток Данных

1.  **Мобильное Приложение (Клиент):**
    *   Собирает URL изображения продукта.
    *   Определяет текущий язык пользователя (`i18n.locale`).
    *   Отправляет **один основной запрос** на вебхук N8N, передавая `imageUrl` и `language`. **НЕ передает** список аллергенов пользователя.

2.  **N8N Workflow (Основной Запрос):**
    *   **Шаг 1 (Webhook):** Получает `imageUrl` и `language`.
    *   **Шаг 2 (LLM - Анализ):**
        *   **Задача:** Проанализировать изображение, извлечь ингредиенты, определить характеристики.
        *   **Промпт:** Инструктирует LLM:
            *   Извлечь `productName`, `brandName`.
            *   Извлечь список `ingredients`.
            *   Для каждого ингредиента:
                *   Определить `name` (название на языке `language`).
                *   Определить `description` (описание на языке `language`).
                *   *Попытаться* определить `isAllergen` (общая оценка LLM, `true`/`false`).
                *   *Попытаться* определить **стандартный `allergenId`** (например, `milk`, `gluten`, `e129`), если ингредиент соответствует известному стандартному аллергену. Если не соответствует, `allergenId = null`.
            *   Сгенерировать `summary`, `recommendations`, `alternatives` (все тексты на языке `language`).
        *   **НЕ** сравнивает с аллергенами пользователя.
        *   **НЕ** вычисляет `personalAllergens`, `commonAllergens`, `safeToConsume`.
    *   **Шаг 3 (N8N Code/Function - Опционально):** Уточнение `allergenId` на основе статического списка стандартных аллергенов и ключевых слов, если LLM его не определила.
    *   **Шаг 4 (Respond to Webhook):** Возвращает JSON в приложение.

3.  **JSON от N8N (Основной Ответ):**
    ```json
    {
      "productName": "Название на языке пользователя",
      "brandName": "Бренд на языке пользователя",
      "imageUrl": "...",
      "timestamp": "...",
      "ingredients": [
        {
          "name": "Ингредиент 1 (язык пользователя)",
          "description": "Описание 1 (язык пользователя)",
          "isAllergen": true,
          "allergenId": "milk" // или null
        },
        {
          "name": "Ингредиент 2 (язык пользователя)",
          "description": "Описание 2 (язык пользователя)",
          "isAllergen": false,
          "allergenId": null
        }
        // ...
      ],
      "summary": "Резюме на языке пользователя",
      "recommendations": "Рекомендации на языке пользователя",
      "alternatives": [ { "name": "...", "description": "..." } ] // На языке пользователя
      // НЕТ полей personalAllergens, commonAllergens, safeToConsume
    }
    ```

4.  **Мобильное Приложение (Обработка Ответа - `parseResponseData`):**
    *   Получает JSON от N8N.
    *   **Локально Загружает Актуальные Данные Пользователя:** Получает *текущий* список *выбранных* аллергенов пользователя из `AsyncStorage` (`getAllUserAllergens`, фильтр по `selected: true`).
    *   **Разделяет Выбранные Пользователем:**
        *   `selectedDefaultIds`: Массив ID стандартных выбранных аллергенов.
        *   `selectedCustomNames`: Массив имен (в нижнем регистре) кастомных выбранных аллергенов.
    *   **Инициализирует Локальные Списки:**
        *   `finalPersonalAllergens`: \[\] (для имен на языке пользователя)
        *   `finalCommonAllergens`: \[\] (для имен на языке пользователя)
    *   **Итерирует по `ingredients` из Ответа N8N:**
        *   Для каждого `ing`:
            *   **Сравнение Стандартных по ID:** Если `ing.allergenId` существует И `ing.allergenId` есть в `selectedDefaultIds` -> добавить `ing.name` в `finalPersonalAllergens`.
            *   **Определение Общих по ID:** Если `ing.allergenId` существует, НО его нет в `selectedDefaultIds` -> добавить `ing.name` в `finalCommonAllergens`.
    *   **Сравнение Кастомных (Второй Вызов LLM или Локально):**
        *   **Способ А (Второй вызов LLM - Рекомендуется для гибкости):**
            *   Собрать имена ингредиентов без `allergenId` (или все).
            *   Собрать `selectedCustomNames`.
            *   Отправить эти два списка на второй, малый LLM-запрос (через N8N или напрямую): "Сравни списки имен с учетом ошибок, верни совпадающие *имена кастомных аллергенов*".
            *   Для каждого совпавшего имени кастомного аллергена найти соответствующий ингредиент в ответе N8N и добавить его `ing.name` в `finalPersonalAllergens`.
        *   **Способ Б (Локальное нечеткое сравнение - Альтернатива):**
            *   Использовать библиотеку fuzzy matching (например, `fuse.js`).
            *   Для каждого ингредиента `ing` без `allergenId` сравнить `ing.name.toLowerCase()` с `selectedCustomNames` с помощью fuzzy match.
            *   При достаточном совпадении -> добавить `ing.name` в `finalPersonalAllergens`.
    *   **Определение `safeToConsume` Локально:** `const safeToConsume = finalPersonalAllergens.length === 0;`
    *   **Формирование `ScanResult`:** Создает финальный объект `ScanResult`, записывая туда:
        *   `personalAllergens`: `finalPersonalAllergens`
        *   `commonAllergens`: `finalCommonAllergens`
        *   `safeToConsume`: вычисленное значение
        *   Остальные поля (`productName`, `ingredients`, `summary` и т.д.) из ответа N8N.
    *   **Сохранение в Историю:** Сохраняет этот `ScanResult` в историю.

5.  **Мобильное Приложение (Отображение - `scan-result.tsx`, `history.tsx`):**
    *   Оба экрана читают данные из сохраненного `ScanResult`.
    *   Статус безопасности определяется **единообразно** на основе поля `safeToConsume` (или `personalAllergens.length === 0`).
    *   Списки "Personal Allergens" и "Common Allergens" рендерятся на основе соответствующих полей в `ScanResult`.

## Преимущества

*   **Надежность:** Сравнение стандартных аллергенов по ID.
*   **Гибкость:** Обработка кастомных аллергенов с помощью LLM/fuzzy matching.
*   **Актуальность:** Сравнение с последними данными пользователя.
*   **Консистентность:** Единая логика определения статуса для всех экранов.
*   **Эффективность:** Основной запрос N8N не перегружен списком аллергенов.
*   **Локализация:** Корректная обработка и отображение на разных языках.

## Недостатки/Сложности

*   Требуется второй вызов LLM (если выбран Способ А для кастомных) или реализация fuzzy matching (Способ Б).
*   Точность `allergenId` от N8N для стандартных аллергенов зависит от LLM/доп. логики N8N. 